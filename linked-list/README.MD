# Singly Linked List
<!-- Short summary or background information -->

## Challenge
<!-- Description of the challenge -->

Write a Linked List from the scratch.

Linked List as some functionality 
like `add`, `insert`, `includes`.

## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->

OOP Approach for flexibility and 
exy to read and fix.

O in this approach it not efficient 
because I use `while` for `add`, 
`insert`, `includes`, `print`.

## API
<!-- Description of each method publicly available to your Linked List -->

`add` add the data and check if Linked 
List have head or not, in this method 
it will not return anything, it is a 
public method.

`insert` insert the data and check if 
Linked List have head or not, in this 
method it will not return anything, 
it is a public method.

`includes` search reserve value and 
check of the Linked List has a size it 
will search at each data in Linked List, 
in this method it will return true or 
false, it is a public method.

`append` insert the data and check if
Linked List have head or not, in this
method it will not return anything,
it is a public method.

`insertAfter` passing two arguments (after, data)
search for after at Linked List after that insert
data in next node.

`insertBefore` passing two arguments (before, data)
search for after at Linked List after that insert
data in previous node.

`insertAtFirst` insert at the first and move the
head to new node add it.

`kthFromEnd` return node from the tail until 
the end depends on k(index) insert

`zipLists` insert in it 2 list, and it will 
merge them, start form 
list one to list two and `zipListsInsert` 
reserve each node form 2 list and start 
throw of list like a chain intel get 
end of node.

`reverse` git a head form likened list
start chain the previous to current,
and current to next unto get null at
current then restore all previous at 
new head.

`palindrome` divided the node into 
the middle and second half, get 
head at printer first, second, 
previous, check if head not null 
and next node, not null, start 
looping to get the half get a 
`reverse()` after that start 
comparison the node after getting 
the result, re `reverse()` 
node start reaching the liked list.

`toString` build in method to print 
the data in class

## Whiteboard Process
<!-- Embedded whiteboard image -->

![linked list](./linked-list.jpg)

## Whiteboard Process
<!-- Embedded whiteboard image -->

![linked list](./kthFromEnd.jpg)


## Whiteboard Process
<!-- Embedded whiteboard image -->

![linked list](./zipLists.jpg)

## Whiteboard Process
<!-- Embedded whiteboard image -->

![palindrome](./palindrome.jpg)

Interviewer: Motasim Al-Azzam

Student: Mohammad Abu Mattar

rviewer dic link: https://docs.google.com/spreadsheets/d/1YQz7FJkXwwB7D60bMAneqv-tHTe83Wfb1T1WqSRMI-Y/edit?usp=sharing

